What happens when you initialize a repository? Why do you need to do it?
------------------------------------------------------------------------
I see a message saying, an empty git repository has been initiialized. And from what I see in
the video, a hidden .git folder is created after I do "git init". I think I will need it to
start tracking files. I can't start tracking files without initializing git repository. It
contains all metadata and history about my files. git init creates an empty skeleton for that. 

How is the staging area different from the working directory and the repository? What value do
you think it offers?
----------------------------------------------------------------------------
Directory is the actual directory with files in it. It's the content. Repository is my directory
plus its history and extra meta data about the directory file contents. Staging area on the
other hand acts as an intermediary. It's not exactly directory nor is it a repository. It's what
the name implies, a staging area. It's like the place where you first add the files and then
commit into git. It's a stage before I change the state of git repository (as in the data about
changes) since my working files have already changed but the data about where and how the files
have changed hasn't been recorded yet. 
      One good thing about staging area that I can think of is, I can add only the files I want
and other files would be unchanged in the new snapshot except the file I commited which would be
different. Moreover, it can act as a comfirmation dialogue before I actually commit something to
make sure about what I am actually committing, so that I don't actually commit what I don't want
to. It acts like a buffer.

How can you use the staging area to make sure you have one commit per logical change?
----------------------------------------------------------------------------
I will add only the files I need to the staging area. I can use the staging area to see what has
changed between the previous commit and now. Whatever files are changed, I can see them using
git diff which compares files between staging area and working directory. Using this, I can
decide which files I need to add and what changes have been made. I can use this to create a
commit which has only one logical change. I can further compare the staged changes with the
repository to make sure the changes I am adding represent a single logical change.  

What are some situations when branches would be helpful in keeping your history organized? How
would branches help?
----------------------------------------------------------------------------
When I want to work on a new feature I can just create a new branch and work on it without
worrying about the changes to my master or main branch. My main code will remain unchanged while
I can try new things in my branch. When I am done with the changes in branch, I can just go to
main code and I would see now changes there. This would help to avoid mixing up the changes. I
get a separate history and a virtual directory to try new things and the history of that
directory will be accessed only from that branch while main history remains untouched. It will
make the history and code in general easy to navigate and manage. 

How do the diagrams help you visualize the branch structure?
----------------------------------------------------------------------------
Eto, diagrams make it easier to understand what's actually happening inside git, how the history
is stored. It also helps in tracing the parents and hence make it easier to understand why some
commits show up in git log while others don't. Diagrams also explain what's called HEAD and
HEADless state. HEADless state is when I checkout an old commit and make new changes and commit
them. The new commit will appear as a separate branch which doesn't have any name. It would be
something like an anonymous branch and unless I create a new branch for that commit or
note/remember that commit, there would be no way to access it.

What is the result of merging two branches together? Why do we represent it in
the diagram the way we do?

What are the pros and cons of Gitâ€™s automatic merging vs. always doing merges
manually?
